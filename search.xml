<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[spring bean 加载流程]]></title>
      <url>/2017/08/10/spring/</url>
      <content type="html"><![CDATA[<h1 id="几个重要的类"><a href="#几个重要的类" class="headerlink" title="几个重要的类"></a>几个重要的类</h1><ul>
<li>ResourceLoader: 资源加载器，根据给定的资源文件地址，返回对应的Resource。常用的有ClassPathResource,UrlResource,FileSystemResource.</li>
<li>DocumentLoader: 定义从资源文件加载到转换为document的功能。</li>
<li>BeanDefinitionReader: 定义资源文件的读取并转化为BeanDefinition的功能。</li>
<li>DefaultBeanDefinitionDocumentReader：定义读取document并注册beanDefinition的功能。</li>
<li>BeanDefinitionParseDelegate: 定义解析element的各种方法。</li>
<li>BeanDefinitionRegistry: 定义对beanDefinition的各种增删改查的操作。</li>
<li>BeanDefinition: 对应配置文件中的一个\<bean>标签,包含多种属性，例如className,lookUp,lazyInit,dependsOn,FactoryMethod</bean></li>
</ul>
<h1 id="Bean初始化的流程"><a href="#Bean初始化的流程" class="headerlink" title="Bean初始化的流程"></a>Bean初始化的流程</h1><blockquote>
<h2 id="从配置文件到bean的注册"><a href="#从配置文件到bean的注册" class="headerlink" title="从配置文件到bean的注册"></a>从配置文件到bean的注册</h2><p> 1，资源文件的读取（ResourceLoader，DocumentLoader）<br> 2，转化为beanDefinition对象（BeanDefinitionReader，DefaultBeanDefinitionDocumentReader，BeanDefinitionParseDelegate）<br> 3，将bean注册到容器中（BeanDefinitionRegistry）</p>
</blockquote>
<h2 id="Bean的加载"><a href="#Bean的加载" class="headerlink" title="Bean的加载"></a>Bean的加载</h2><h3 id="spring如何解决依赖注入的循环依赖问题"><a href="#spring如何解决依赖注入的循环依赖问题" class="headerlink" title="spring如何解决依赖注入的循环依赖问题"></a>spring如何解决依赖注入的循环依赖问题</h3><blockquote>
<p>通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。<br>对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的Bean来完成的，而且只能解决单例作用域的Bean循环依赖。</p>
<blockquote>
<p>1、Spring容器创建单例“circleA” Bean，首先根据无参构造器创建Bean，并暴露一个“ObjectFactory ”用于返回一个提前暴露一个创建中的Bean，并将“circleA” 标识符放到“当前创建Bean池”；然后进行setter注入“circleB”；<br>2、Spring容器创建单例“circleB” Bean，首先根据无参构造器创建Bean，并暴露一个“ObjectFactory”用于返回一个提前暴露一个创建中的Bean，并将“circleB” 标识符放到“当前创建Bean池”，然后进行setter注入“circleC”；<br>3、Spring容器创建单例“circleC” Bean，首先根据无参构造器创建Bean，并暴露一个“ObjectFactory ”用于返回一个提前暴露一个创建中的Bean，并将“circleC” 标识符放到“当前创建Bean池”，然后进行setter注入“circleA”；进行注入“circleA”时由于提前暴露了“ObjectFactory”工厂从而使用它返回提前暴露一个创建中的Bean；<br>4、最后在依赖注入“circleB”和“circleA”，完成setter注入。</p>
</blockquote>
<p>对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。</p>
</blockquote>
<h3 id="在Bean加载过程中涉及的几种map"><a href="#在Bean加载过程中涉及的几种map" class="headerlink" title="在Bean加载过程中涉及的几种map"></a>在Bean加载过程中涉及的几种map</h3><ul>
<li>singletonObjects: 用于保存beanName和创建的Bean实例之间的关系。</li>
<li>singletonFactories: 用于保存beanName和创建bean的工厂之间的关系。</li>
<li>earlySingletonObjects: 保存beanName和创建的bean实例之间的关系，与singletonObjects不同在于当一个bean被放入此map中时，即使还处于创建过程中，也可以通过getBean方法获取，主要用于检测循环依赖。</li>
<li>registeredSingletons：用于保存当前所有已注册的bean.</li>
</ul>
<hr>
<h4 id="使用FactoryBean"><a href="#使用FactoryBean" class="headerlink" title="使用FactoryBean"></a>使用FactoryBean</h4><p>&#8194;&#8194;&#8194;&#8194;跟普通Bean不同，其返回的对象不是指定类的一个实例，其返回的是该FactoryBean的getObject方法所返回的对象。在Spring框架内部，有很多地方有FactoryBean的实现类，它们在很多应用如(Spring的AOP、ORM、事务管理)及与其它第三框架(ehCache)集成时都有体现.</p>
<p>FactoryBean接口有3个方法：<br>&#8194;&#8194;&#8194;&#8194;Object getObject():返回本工厂创建的对象实例。此实例也许是共享的，依赖于该工厂返回的是单例或者是原型。<br>&#8194;&#8194;&#8194;&#8194;boolean isSingleton():如果FactoryBean返回的是单例,该方法返回值为true,否则为false<br>&#8194;&#8194;&#8194;&#8194;Class getObjectType():返回对象类型。对象类型是getObject()方法返回的对象的类型，如果不知道的类型则返回null。</p>
<p>FactoryBean概念和接口在Spring框架中大量使用。Spring内置的有超过50个实现。<br>&#8194;&#8194;&#8194;&#8194;当使用ApplicationContext的getBean()方法获取FactoryBean实例本身而不是它所产生的bean，则要使用&amp;符号+id。比如，现有FactoryBean，它有id，在容器上调用getBean(“myBean”)将返回FactoryBean所产生的bean，调用getBean(“&amp;myBean”)将返回FactoryBean它本身的实例。</p>
<h2 id="Bean的创建"><a href="#Bean的创建" class="headerlink" title="Bean的创建"></a>Bean的创建</h2><h4 id="creatBean"><a href="#creatBean" class="headerlink" title="creatBean"></a>creatBean</h4><p>&#8194;&#8194;&#8194;&#8194;在创建Bean对象时，如果没有需要覆盖的方法（beanDefinition.getMethodOverrides()为空，则默认使用反射的方式创建对象。如果有需要覆盖的方法，则需要使用动态代理的方式来实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123;</div><div class="line">		// Don&apos;t override the class with CGLIB if no overrides.</div><div class="line">		if (bd.getMethodOverrides().isEmpty()) &#123;</div><div class="line">			Constructor&lt;?&gt; constructorToUse;</div><div class="line">			synchronized (bd.constructorArgumentLock) &#123;</div><div class="line">				constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod;</div><div class="line">				if (constructorToUse == null) &#123;</div><div class="line">					final Class&lt;?&gt; clazz = bd.getBeanClass();</div><div class="line">					if (clazz.isInterface()) &#123;</div><div class="line">						throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;);</div><div class="line">					&#125;</div><div class="line">					try &#123;</div><div class="line">						if (System.getSecurityManager() != null) &#123;</div><div class="line">							constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123;</div><div class="line">								@Override</div><div class="line">								public Constructor&lt;?&gt; run() throws Exception &#123;</div><div class="line">									return clazz.getDeclaredConstructor((Class[]) null);</div><div class="line">								&#125;</div><div class="line">							&#125;);</div><div class="line">						&#125;</div><div class="line">						else &#123;</div><div class="line">							constructorToUse =	clazz.getDeclaredConstructor((Class[]) null);</div><div class="line">						&#125;</div><div class="line">						bd.resolvedConstructorOrFactoryMethod = constructorToUse;</div><div class="line">					&#125;</div><div class="line">					catch (Throwable ex) &#123;</div><div class="line">						throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">			return BeanUtils.instantiateClass(constructorToUse);</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">			// Must generate CGLIB subclass.</div><div class="line">			return instantiateWithMethodInjection(bd, beanName, owner);</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<h3 id="populateBean-设置Bean属性注入"><a href="#populateBean-设置Bean属性注入" class="headerlink" title="populateBean 设置Bean属性注入"></a>populateBean 设置Bean属性注入</h3><p>&#8194;&#8194;&#8194;&#8194;Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123;  </div><div class="line">        //获取Bean定义的属性值，并对属性值进行处理  </div><div class="line">        PropertyValues pvs = mbd.getPropertyValues();  </div><div class="line">        ……  </div><div class="line">        //对依赖注入处理，首先处理autowiring自动装配的依赖注入  </div><div class="line">        if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME ||  </div><div class="line">                mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </div><div class="line">            MutablePropertyValues newPvs = new MutablePropertyValues(pvs);  </div><div class="line">            //根据Bean名称进行autowiring自动装配处理  </div><div class="line">            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123;  </div><div class="line">                autowireByName(beanName, mbd, bw, newPvs);  </div><div class="line">            &#125;  </div><div class="line">            //根据Bean类型进行autowiring自动装配处理  </div><div class="line">            if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123;  </div><div class="line">                autowireByType(beanName, mbd, bw, newPvs);  </div><div class="line">            &#125;  </div><div class="line">        &#125;  </div><div class="line">//对非autowiring的属性进行依赖注入处理</div></pre></td></tr></table></figure>
<h3 id="initializeBean-初始化Bean"><a href="#initializeBean-初始化Bean" class="headerlink" title="initializeBean 初始化Bean"></a>initializeBean 初始化Bean</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123;</div><div class="line">		if (System.getSecurityManager() != null) &#123;</div><div class="line">			AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123;</div><div class="line">				@Override</div><div class="line">				public Object run() &#123;</div><div class="line">					invokeAwareMethods(beanName, bean);</div><div class="line">					return null;</div><div class="line">				&#125;</div><div class="line">			&#125;, getAccessControlContext());</div><div class="line">		&#125;</div><div class="line">		else &#123;</div><div class="line">		//实现Aware接口，注入感知的对象</div><div class="line">			invokeAwareMethods(beanName, bean);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Object wrappedBean = bean;</div><div class="line">		//实现BeanPostProcessor,应用postProcessBeforeInitialization方法。</div><div class="line">		//在Bean的初始化前提供回调入口</div><div class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</div><div class="line">			wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName);</div><div class="line">		&#125;</div><div class="line"></div><div class="line"></div><div class="line">		try &#123;</div><div class="line">		//应用配置的init-method方法</div><div class="line">			invokeInitMethods(beanName, wrappedBean, mbd);</div><div class="line">		&#125;</div><div class="line">		catch (Throwable ex) &#123;</div><div class="line">			throw new BeanCreationException(</div><div class="line">					(mbd != null ? mbd.getResourceDescription() : null),</div><div class="line">					beanName, &quot;Invocation of init method failed&quot;, ex);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		//实现BeanPostProcessor,应用postProcessBeforeInitialization方法。</div><div class="line">		//在Bean的初始化之后提供回调入口</div><div class="line">		if (mbd == null || !mbd.isSynthetic()) &#123;</div><div class="line">			wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName);</div><div class="line">		&#125;</div><div class="line">		return wrappedBean;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<hr>
<h3 id="上一张图"><a href="#上一张图" class="headerlink" title="上一张图"></a>上一张图</h3><p><img src="../images/bean初始化.png" alt=""></p>
]]></content>
      
        <categories>
            
            <category> spring </category>
            
        </categories>
        
        
        <tags>
            
            <tag> spring </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
