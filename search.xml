<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring bean 加载流程]]></title>
    <url>%2F2017%2F08%2F10%2Fspring%2F</url>
    <content type="text"><![CDATA[几个重要的类 ResourceLoader: 资源加载器，根据给定的资源文件地址，返回对应的Resource。常用的有ClassPathResource,UrlResource,FileSystemResource. DocumentLoader: 定义从资源文件加载到转换为document的功能。 BeanDefinitionReader: 定义资源文件的读取并转化为BeanDefinition的功能。 DefaultBeanDefinitionDocumentReader：定义读取document并注册beanDefinition的功能。 BeanDefinitionParseDelegate: 定义解析element的各种方法。 BeanDefinitionRegistry: 定义对beanDefinition的各种增删改查的操作。 BeanDefinition: 对应配置文件中的一个bean标签,包含多种属性，例如className,lookUp,lazyInit,dependsOn,FactoryMethod Bean初始化的流程 从配置文件到bean的注册 1，资源文件的读取（ResourceLoader，DocumentLoader） 2，转化为beanDefinition对象（BeanDefinitionReader，DefaultBeanDefinitionDocumentReader，BeanDefinitionParseDelegate） 3，将bean注册到容器中（BeanDefinitionRegistry） Bean的加载spring如何解决依赖注入的循环依赖问题 通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。对于setter注入造成的依赖是通过Spring容器提前暴露刚完成构造器注入但未完成其他步骤（如setter注入）的Bean来完成的，而且只能解决单例作用域的Bean循环依赖。 1、Spring容器创建单例“circleA” Bean，首先根据无参构造器创建Bean，并暴露一个“ObjectFactory ”用于返回一个提前暴露一个创建中的Bean，并将“circleA” 标识符放到“当前创建Bean池”；然后进行setter注入“circleB”；2、Spring容器创建单例“circleB” Bean，首先根据无参构造器创建Bean，并暴露一个“ObjectFactory”用于返回一个提前暴露一个创建中的Bean，并将“circleB” 标识符放到“当前创建Bean池”，然后进行setter注入“circleC”；3、Spring容器创建单例“circleC” Bean，首先根据无参构造器创建Bean，并暴露一个“ObjectFactory ”用于返回一个提前暴露一个创建中的Bean，并将“circleC” 标识符放到“当前创建Bean池”，然后进行setter注入“circleA”；进行注入“circleA”时由于提前暴露了“ObjectFactory”工厂从而使用它返回提前暴露一个创建中的Bean；4、最后在依赖注入“circleB”和“circleA”，完成setter注入。 对于“prototype”作用域Bean，Spring容器无法完成依赖注入，因为“prototype”作用域的Bean，Spring容器不进行缓存，因此无法提前暴露一个创建中的Bean。 在Bean加载过程中涉及的几种map singletonObjects: 用于保存beanName和创建的Bean实例之间的关系。 singletonFactories: 用于保存beanName和创建bean的工厂之间的关系。 earlySingletonObjects: 保存beanName和创建的bean实例之间的关系，与singletonObjects不同在于当一个bean被放入此map中时，即使还处于创建过程中，也可以通过getBean方法获取，主要用于检测循环依赖。 registeredSingletons：用于保存当前所有已注册的bean. 使用FactoryBean&#8194;&#8194;&#8194;&#8194;跟普通Bean不同，其返回的对象不是指定类的一个实例，其返回的是该FactoryBean的getObject方法所返回的对象。在Spring框架内部，有很多地方有FactoryBean的实现类，它们在很多应用如(Spring的AOP、ORM、事务管理)及与其它第三框架(ehCache)集成时都有体现. FactoryBean接口有3个方法：&#8194;&#8194;&#8194;&#8194;Object getObject():返回本工厂创建的对象实例。此实例也许是共享的，依赖于该工厂返回的是单例或者是原型。&#8194;&#8194;&#8194;&#8194;boolean isSingleton():如果FactoryBean返回的是单例,该方法返回值为true,否则为false&#8194;&#8194;&#8194;&#8194;Class getObjectType():返回对象类型。对象类型是getObject()方法返回的对象的类型，如果不知道的类型则返回null。 FactoryBean概念和接口在Spring框架中大量使用。Spring内置的有超过50个实现。&#8194;&#8194;&#8194;&#8194;当使用ApplicationContext的getBean()方法获取FactoryBean实例本身而不是它所产生的bean，则要使用&amp;符号+id。比如，现有FactoryBean，它有id，在容器上调用getBean(“myBean”)将返回FactoryBean所产生的bean，调用getBean(“&amp;myBean”)将返回FactoryBean它本身的实例。 Bean的创建creatBean&#8194;&#8194;&#8194;&#8194;在创建Bean对象时，如果没有需要覆盖的方法（beanDefinition.getMethodOverrides()为空，则默认使用反射的方式创建对象。如果有需要覆盖的方法，则需要使用动态代理的方式来实现。12345678910111213141516171819202122232425262728293031323334353637public Object instantiate(RootBeanDefinition bd, String beanName, BeanFactory owner) &#123; // Don&apos;t override the class with CGLIB if no overrides. if (bd.getMethodOverrides().isEmpty()) &#123; Constructor&lt;?&gt; constructorToUse; synchronized (bd.constructorArgumentLock) &#123; constructorToUse = (Constructor&lt;?&gt;) bd.resolvedConstructorOrFactoryMethod; if (constructorToUse == null) &#123; final Class&lt;?&gt; clazz = bd.getBeanClass(); if (clazz.isInterface()) &#123; throw new BeanInstantiationException(clazz, &quot;Specified class is an interface&quot;); &#125; try &#123; if (System.getSecurityManager() != null) &#123; constructorToUse = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Constructor&lt;?&gt;&gt;() &#123; @Override public Constructor&lt;?&gt; run() throws Exception &#123; return clazz.getDeclaredConstructor((Class[]) null); &#125; &#125;); &#125; else &#123; constructorToUse = clazz.getDeclaredConstructor((Class[]) null); &#125; bd.resolvedConstructorOrFactoryMethod = constructorToUse; &#125; catch (Throwable ex) &#123; throw new BeanInstantiationException(clazz, &quot;No default constructor found&quot;, ex); &#125; &#125; &#125; return BeanUtils.instantiateClass(constructorToUse); &#125; else &#123; // Must generate CGLIB subclass. return instantiateWithMethodInjection(bd, beanName, owner); &#125; &#125; populateBean 设置Bean属性注入&#8194;&#8194;&#8194;&#8194;Spring IoC容器根据Bean名称或者类型进行autowiring自动依赖注入 123456789101112131415161718protected void populateBean(String beanName, AbstractBeanDefinition mbd, BeanWrapper bw) &#123; //获取Bean定义的属性值，并对属性值进行处理 PropertyValues pvs = mbd.getPropertyValues(); …… //对依赖注入处理，首先处理autowiring自动装配的依赖注入 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME || mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; MutablePropertyValues newPvs = new MutablePropertyValues(pvs); //根据Bean名称进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_NAME) &#123; autowireByName(beanName, mbd, bw, newPvs); &#125; //根据Bean类型进行autowiring自动装配处理 if (mbd.getResolvedAutowireMode() == RootBeanDefinition.AUTOWIRE_BY_TYPE) &#123; autowireByType(beanName, mbd, bw, newPvs); &#125; &#125; //对非autowiring的属性进行依赖注入处理 initializeBean 初始化Bean12345678910111213141516171819202122232425262728293031323334353637383940protected Object initializeBean(final String beanName, final Object bean, RootBeanDefinition mbd) &#123; if (System.getSecurityManager() != null) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Object&gt;() &#123; @Override public Object run() &#123; invokeAwareMethods(beanName, bean); return null; &#125; &#125;, getAccessControlContext()); &#125; else &#123; //实现Aware接口，注入感知的对象 invokeAwareMethods(beanName, bean); &#125; Object wrappedBean = bean; //实现BeanPostProcessor,应用postProcessBeforeInitialization方法。 //在Bean的初始化前提供回调入口 if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsBeforeInitialization(wrappedBean, beanName); &#125; try &#123; //应用配置的init-method方法 invokeInitMethods(beanName, wrappedBean, mbd); &#125; catch (Throwable ex) &#123; throw new BeanCreationException( (mbd != null ? mbd.getResourceDescription() : null), beanName, &quot;Invocation of init method failed&quot;, ex); &#125; //实现BeanPostProcessor,应用postProcessBeforeInitialization方法。 //在Bean的初始化之后提供回调入口 if (mbd == null || !mbd.isSynthetic()) &#123; wrappedBean = applyBeanPostProcessorsAfterInitialization(wrappedBean, beanName); &#125; return wrappedBean; &#125; 上一张图]]></content>
      <categories>
        <category>spring</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
</search>
